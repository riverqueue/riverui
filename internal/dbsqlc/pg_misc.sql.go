// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pg_misc.sql

package dbsqlc

import (
	"context"
)

const indexExistsInCurrentSchema = `-- name: IndexExistsInCurrentSchema :one
SELECT EXISTS (
    SELECT 1
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = current_schema()
    AND c.relname = $1::text
    AND c.relkind = 'i'
)
`

func (q *Queries) IndexExistsInCurrentSchema(ctx context.Context, db DBTX, indexName string) (bool, error) {
	row := db.QueryRow(ctx, indexExistsInCurrentSchema, indexName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const indexesExistInCurrentSchema = `-- name: IndexesExistInCurrentSchema :many
WITH index_names AS (
    SELECT unnest($1::text[]) as index_name
)
SELECT index_names.index_name::text,
       EXISTS (
         SELECT 1
         FROM pg_catalog.pg_class c
         JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
         WHERE n.nspname = current_schema()
         AND c.relname = index_names.index_name
         AND c.relkind = 'i'
       ) AS exists
FROM index_names
`

type IndexesExistInCurrentSchemaRow struct {
	IndexNamesIndexName string
	Exists              bool
}

func (q *Queries) IndexesExistInCurrentSchema(ctx context.Context, db DBTX, indexNames []string) ([]*IndexesExistInCurrentSchemaRow, error) {
	rows, err := db.Query(ctx, indexesExistInCurrentSchema, indexNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*IndexesExistInCurrentSchemaRow
	for rows.Next() {
		var i IndexesExistInCurrentSchemaRow
		if err := rows.Scan(&i.IndexNamesIndexName, &i.Exists); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tableExistsInCurrentSchema = `-- name: TableExistsInCurrentSchema :one
SELECT EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_schema = current_schema()
    AND table_name = $1::text
)
`

func (q *Queries) TableExistsInCurrentSchema(ctx context.Context, db DBTX, tableName string) (bool, error) {
	row := db.QueryRow(ctx, tableExistsInCurrentSchema, tableName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
