// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: river_producer.sql

package dbsqlc

import (
	"context"
)

const producerListByQueue = `-- name: ProducerListByQueue :many
SELECT
    river_producer.id, river_producer.client_id, river_producer.queue_name, river_producer.max_workers, river_producer.metadata, river_producer.paused_at, river_producer.created_at, river_producer.updated_at,
    COALESCE(
        (
            SELECT SUM(
                CASE
                    WHEN jsonb_typeof(value) = 'number' THEN (value)::int
                    ELSE (value->>'count')::int
                END
            )
            FROM jsonb_each(metadata->'concurrency'->'running')
        ),
        0
    )::int as running
FROM river_producer
WHERE queue_name = $1
ORDER BY id ASC
`

type ProducerListByQueueRow struct {
	RiverProducer RiverProducer
	Running       int32
}

func (q *Queries) ProducerListByQueue(ctx context.Context, db DBTX, queueName string) ([]*ProducerListByQueueRow, error) {
	rows, err := db.Query(ctx, producerListByQueue, queueName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ProducerListByQueueRow
	for rows.Next() {
		var i ProducerListByQueueRow
		if err := rows.Scan(
			&i.RiverProducer.ID,
			&i.RiverProducer.ClientID,
			&i.RiverProducer.QueueName,
			&i.RiverProducer.MaxWorkers,
			&i.RiverProducer.Metadata,
			&i.RiverProducer.PausedAt,
			&i.RiverProducer.CreatedAt,
			&i.RiverProducer.UpdatedAt,
			&i.Running,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
